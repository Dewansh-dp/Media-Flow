import { asyncHandler } from "../utils/asyncHandler.js";
import { ApiError } from "../utils/ApiError.js";
import { User } from "../models/user.model.js";
import {
   uploadOnCloudinary,
   deleteFromCloudinary,
} from "../utils/cloudinary.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import jwt from "jsonwebtoken";
import path from "path";
import axios from "axios";
import fs from "fs";

//this is a local funtion to generate token
const generateAccessAndRefreshToken = async (userId) => {
   try {
      const user = await User.findById(userId);

      const accessToken = user.generateAccessToken();
      const refreshToken = user.generateRefreshToken();

      // inserting the token in user object
      user.refreshToken = refreshToken;
      //we have not validated user before saving it to the db because of the pre-middleware("save") that will encrypt password always when we save a user
      await user.save({ validateBeforeSave: false });

      return { accessToken, refreshToken };
   } catch (error) {
      throw new ApiError(500, "Something went wrong while generating token");
   }
};

const registerUser = asyncHandler(async (req, res) => {
   /*    Algorithm for registering user
   get user details from frontend {fullname ,username,password,email}
   validate fields - not empty
   check if user already exists: username, email
   check for images and avatar
   upload them to cloudinary: avatar
   create user object - create entry in db
   remove password and refresh token field from response
   check for user creation
   return res 
   */

   //while sending the req we added json inside request's body
   const { userName, fullName, password, email } = req.body;
   console.log(userName, fullName, password, email);
   //   {avatar,coverImage are taken from the multer middleware }
   // console.log(req.files, req.route, req.body);

   //validation of the fields if they are empty
   // if(userName==="") (writing same if condition for all the fields is same as below codition)
   if (
      [userName, fullName, email, password].some(
         (field) => field?.trim() === "" || field?.trim() === undefined
         // ?. is optional chaining operator(if the field is null or undefined) it will return undefined when used with trim to prevent the error cannot read properties of null generated by => (null/undefined).trim()
         // both conditions check for [filled with whitespaces] or null or undefined
      )
   ) {
      throw new ApiError(400, "All fields are required");
   }

   //check if the user already exists
   const existedUser = await User.findOne({
      $or: [{ userName }, { email }], // try using {userName:userName}
   });
   // console.log("existedUser->", existedUser);

   if (existedUser) {
      throw new ApiError(409, "User with username or email already existed");
   }
   // console.log(req.files);
   // console.log(req.files.avatar);
   // console.log(req.files?.avatar?.[0]);
   // console.log(req.files?.avatar?.[0].path);

   // obtaining local path for the uploaded files
   const avatarLocalPath = req.files?.avatar?.[0].path;
   const coverImageLocalPath = req.files?.coverImage?.[0]?.path;

   // console.log(avatarLocalPath);

   //checking if avatar is present or not
   if (!avatarLocalPath) {
      throw new ApiError(400, "Avatar file is required");
   }

   const avatar = await uploadOnCloudinary(avatarLocalPath, "Youtube/Users");
   const coverImage = await uploadOnCloudinary(
      coverImageLocalPath,
      "Youtube/Users"
   );

   // console.log(avatar);
   // console.log(coverImage);

   if (!avatar) {
      throw new ApiError(400, "Avatar file is required ");
   }

   const user = await User.create({
      fullName,
      avatar: avatar.secure_url,
      // if coverImage url is not present then leave empty string
      coverImage: coverImage?.secure_url || "",
      userName: userName.toLowerCase(),
      password,
      email,
   });

   // console.log(user);

   //checking if the user is registered in db
   //removing password and refreshToken field from the response
   const createdUser = await User.findById(user._id).select(
      "-password -refreshToken"
   );
   if (!createdUser) {
      throw new ApiError(500, "Something went wrong while registering user");
   }
   // console.log(User);

   res.status(201).json(
      new ApiResponse(200, createdUser, "User resgistered successfully")
   );

   console.log("User registered");
});

const loginUser = asyncHandler(async (req, res) => {
   /* 
      taking data from the user (email,username,password)
      find user in db
      password check
      generate access and refresh token 
      send cookies
   */

   const { userName, email, password } = req.body;
   // console.log(userName, email, password);

   //checking if we have the required data
   if (!(userName || email) && !password) {
      throw new ApiError(400, "Username or email and password are required");
   }

   //finding user in db
   const user = await User.findOne({
      $or: [{ userName }, { email }],
   });

   if (!user) {
      throw new ApiError(400, "User does not exist");
   }

   //checking if the password is correct
   const isPasswordValid = await user.isPasswordCorrect(password);
   if (!isPasswordValid) {
      throw new ApiError(404, "Invalid user credentials");
   }

   //generating refresh and access token via local funtion
   const { accessToken, refreshToken } = await generateAccessAndRefreshToken(
      user._id
   );

   // console.log(user);

   //getting the updated user which now have the refreshToken
   //we can also get the updated user from the above code as well
   const loggedInUser = await User.findById(user._id).select(
      "-password -refreshToken"
   );

   const options = {
      // frontend(user) will not be able to modify cookies only the server can
      httpOnly: true,
      secure: true,
      maxAge: Number(process.env.COOKIE_EXPIRY), //(10 days ,time in ms)
   };
   res.status(200)
      .cookie("accessToken", accessToken, options)
      .cookie("refreshToken", refreshToken, options)
      .json(
         new ApiResponse(
            200,
            {
               user: loggedInUser,
               refreshToken,
               accessToken,
            },
            "User loggedin successfully"
         )
      );
   // console.log(req.cookies.refreshToken);

   console.log("User loggedin");
});

const logoutUser = asyncHandler(async (req, res) => {
   /* 
   we dont have access to user in logout so we design a middleware and get the access of user like 
   - taking tonken out from cookies 
   - verifying token 
   - getting _id from the token 
   - getting user
   after getting the uesr we add it to the req 
   and finally we obtain custom user object for the req holding user field inside(which we added)
   */

   const updated_user = await User.findByIdAndUpdate(
      // we have inserted user in the req via auth.middleware
      req.user._id,
      {
         // $set: {
         // mongodb by default ignores the values like undefined, hence the $set will have no effect
         //    refreshToken: "undefined",
         // },
         $unset: {
            // used to remove the field
            refreshToken: 1,
         },
      },
      {
         // "new" returns the new updated user with refreshToken set undefined
         new: true,
      }
   );
   // console.log(updated_user);

   const options = {
      httpOnly: true,
      secure: true,
   };
   // console.log(updated_user);

   res.status(200)
      .clearCookie("accessToken", "", options)
      .clearCookie("refreshToken", "", options)
      .json(new ApiResponse(200, {}, "User logged out"));

   console.log("User loggedout");
});

const refreshAccessToken = asyncHandler(async (req, res) => {
   /* 
      for refreshing access token 
      obtaining refresh token from cookies
      decoding refresh token 
      getting user from db
      comparing req.refreshToken and user.refreshToken
      generate new tokens(access and refresh)
      sending cookies with new tokens(both)
    */

   const incomingRefreshToken =
      req.cookies.refreshToken || req.body.refreshToken;

   if (!incomingRefreshToken) {
      throw new ApiError(401, "Unauthorized request");
   }

   try {
      const decodedToken = jwt.verify(
         incomingRefreshToken,
         process.env.REFRESH_TOKEN_SECRET
      );
      // console.log(decodedToken);

      const user = await User.findById(decodedToken?._id);
      // console.log(user);

      if (!user) {
         throw new ApiError(401, "Invalid refresh token");
      }

      if (incomingRefreshToken !== user.refreshToken) {
         throw new ApiError(401, "Refresh token is expired or used");
      }

      const { accessToken, refreshToken } = await generateAccessAndRefreshToken(
         user._id
      );

      const options = {
         httpOnly: true,
         secure: true,
         maxAge: Number(process.env.COOKIE_EXPIRY), //(10 days ,time in ms)
      };
      res.status(200)
         .cookie("accessToken", accessToken, options)
         .cookie("refreshToken", refreshToken, options)
         .json(
            new ApiResponse(
               200,
               { accessToken, refreshToken },
               "Access token refreshed"
            )
         );
   } catch (error) {
      throw new ApiError(401, error?.message || "Invalid refresh token");
   }

   console.log("Token refreshed");
});

const changeCurrentPassword = asyncHandler(async (req, res) => {
   const { oldPassword, newPassword } = req.body;

   const user = await User.findById(req.user?._id);

   const isPasswordValid = user.isPasswordCorrect(oldPassword);

   if (!isPasswordValid) {
      throw new ApiError(400, "Password is incorrect");
   }

   user.password = newPassword;

   await user.save({ validateBeforeSave: false });

   res.status(200).json(
      new ApiResponse(200, {}, "Password changed successfully")
   );

   console.log("Password changed");
});

const getCurrentUser = asyncHandler(async (req, res) => {
   res.status(200).json(
      new ApiResponse(200, req.user, "current user fetched successfully")
   );
});

const updateAccountDetails = asyncHandler(async (req, res) => {
   const { fullName, email } = req.body;

   if (!fullName || !email) {
      throw new ApiError(400, "Fullname or email is required");
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set: {
            fullName,
            email,
         },
      },
      {
         new: true,
      }
   ).select("-password -refreshToken");

   res.status(200).json(
      new ApiResponse(200, user, "Account details updated successfully")
   );
   console.log("User details updated successfully");
});

const updateUserAvatar = asyncHandler(async (req, res) => {
   // deleting old avatar from cloudinary
   const oldAvatarUrl = req.user?.avatar;
   const urlArray = oldAvatarUrl.split("/");
   const filename = urlArray.pop();
   const oldAvatarPublicId = filename.split(".")[0];
   // console.log("oldAvatarPublicId", oldAvatarPublicId);
   await deleteFromCloudinary("Youtube/Users/" + oldAvatarPublicId, "image");

   // here we have used "file" instead of "files" because we are uploading a single file only
   const avatarLocalPath = req.file?.path;

   if (!avatarLocalPath) {
      throw new ApiError(400, "Avatar file is missing");
   }

   const avatar = await uploadOnCloudinary(avatarLocalPath, "Youtube/Users");

   if (!avatar.url) {
      throw new ApiError(400, "Error while uploading avatar");
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set: {
            avatar: avatar.url,
         },
      },
      { new: true }
   ).select("-password -refreshToken");

   res.status(200).json(
      new ApiResponse(200, user, "Avatar updated successfully")
   );
});

const updateUserCoverImage = asyncHandler(async (req, res) => {
   // deleting old coverImage from cloudinary
   const oldCoverImageUrl = req.user?.coverImage;
   const urlArray = oldCoverImageUrl.split("/");
   const filename = urlArray.pop();
   const oldCoverImagePublicId = filename.split(".")[0];
   // console.log("oldCoverImagePublicId", oldCoverImagePublicId);
   await deleteFromCloudinary(
      "Youtube/Users/" + oldCoverImagePublicId,
      "image"
   );

   // here we have used "file" instead of "files" because we are uploading a single file only
   const coverImageLocalPath = req.file?.path;

   if (!coverImageLocalPath) {
      throw new ApiError(400, "Cover image file is missing");
   }

   const coverImage = await uploadOnCloudinary(
      coverImageLocalPath,
      "Youtube/Users"
   );

   if (!coverImage.url) {
      throw new ApiError(400, "Error while uploading cover image");
   }

   const user = await User.findByIdAndUpdate(
      req.user?._id,
      {
         $set: {
            coverImage: coverImage.secure_url,
         },
      },
      { new: true }
   ).select("-password -refreshToken");

   res.status(200).json(
      new ApiResponse(200, user, "Cover Image updated successfully")
   );
});

const getUserChannelProfile = asyncHandler(async (req, res) => {
   const { userName } = req.params;

   if (!userName?.trim()) {
      throw new ApiError(400, "username is missing");
   }

   const channel = await User.aggregate([
      {
         $match: {
            userName: userName?.toLowerCase(),
         },
      },
      {
         // calculating subscribers (gathering all the documents)
         $lookup: {
            from: "subscriptions",
            localField: "_id",
            foreignField: "channel",
            as: "subscribers",
         },
      },
      {
         // calculating subscribedTo (gathering all the documents)
         $lookup: {
            from: "subscriptions", // mongodb converted "Subscription" schema to "subscriptions"
            localField: "_id",
            foreignField: "subscriber",
            as: "subscribedTo",
         },
      },
      {
         $addFields: {
            // counting subscribers (counting total documents)
            subscribersCount: {
               $size: "$subscribers",
            },

            // counting channelSubscribedTo (counting total documents)
            channelsSubscribedToCount: {
               $size: "$subscribedTo",
            },

            // sending a message to the frontend that the user is subscribed to the visiting channel or not
            isSubscribed: {
               // $cond is the condition (if?then:else)
               $cond: {
                  // subscribers field is an object(array of objects) so we can access the subscriber
                  // in mongodb we can search for the obejcts inside array like $fieldNameOfDocument.objectField
                  if: { $in: [req.user?._id, "$subscribers.subscriber"] },
                  then: true,
                  else: false,
               },
            },
         },
      },
      {
         $lookup: {
            from: "videos",
            localField: "uploads",
            foreignField: "_id",
            as: "uploads",
            pipeline: [
               {
                  $project: {
                     videoFile: 1,
                     title: 1,
                     thumbnail: 1,
                     duration: 1,
                     description: 1,
                  },
               },
            ],
         },
      },
      {
         $project: {
            userName: 1,
            fullName: 1,
            email: 1,
            avatar: 1,
            coverImage: 1,
            subscribersCount: 1,
            channelsSubscribedToCount: 1,
            isSubscribed: 1,
            uploads: 1,
         },
      },
   ]);

   if (!channel?.length) {
      throw new ApiError(404, "Channel does not exists");
   }

   res.status(200).json(
      new ApiResponse(200, channel[0], "User channel fetched successfully")
   );
});

const getWatchHistory = asyncHandler(async (req, res) => {
   const user = await User.aggregate([
      {
         // req.user._id gives us the "string" not the objectId (mongoose converts string into the objectId internally)
         // to find the $match via _id we have to use the actual type ObjectId because mongoose dont convert the aggregate data which we pass on
         // $match: { _id: new mongoose.Schema.Types.ObjectId(req.user._id) },
         $match: { _id: req.user?._id },
      },
      {
         $lookup: {
            from: "videos",
            localField: "watchHistory",
            foreignField: "_id",
            as: "watchHistory",
            pipeline: [
               // this is a subpipeline for the owner field in videos
               //we are inside videos schema
               {
                  // this is to insert the owner details (user details)
                  $lookup: {
                     from: "users",
                     localField: "owner",
                     foreignField: "_id",
                     as: "owner",
                     pipeline: [
                        {
                           // this projection is for the field 'owner'
                           $project: {
                              userName: 1,
                              fullName: 1,
                              avatar: 1,
                           },
                        },
                     ],
                  },
               },
               {
                  $addFields: {
                     // this is only written for taking out data from the arrays first element (i.e. destructuring the array)
                     owner: {
                        $first: "$owner",
                        // $arrayElemAt: ["$owner", 0],  // this work same as above
                     },
                  },
               },
            ],
         },
      },
      {
         $project: {
            watchHistory: 1,
         },
      },
   ]);

   res.status(200).json(
      new ApiResponse(
         200,
         user[0].watchHistory,
         "Watch history fetched successfully"
      )
   );
});

const downloadAvatar = asyncHandler(async (req, res) => {
   const url = req.user.avatar;

   const response = await axios.get(url, { responseType: "stream" });

   /* Downloading file locally 

      //local path of the directory where we want to download the file
      const dirName = "./public/temp";
      // the above path is not a valid path it should use "\" instead of "/"
      // to do so we use path.join()
      const localPath = path.join(dirName, "Downloaded File.jpg");
      response.data.pipe(fs.createWriteStream(localPath));

   */
   res.set({
      "content-type": response.headers.getContentType(),
      "content-disposition": `attachment; filename="Fetched from DB.png"`,
   });

   // response.data is a readable stream
   // pipe method allows to connect readable stream to a writable stream
   // res is a writable stream (we can write data to it)
   response.data.pipe(res);
   res.status(200);
});

const downloadCoverImage = asyncHandler(async (req, res) => {
   const url = req.user.coverImage;

   const response = await axios.get(url, { responseType: "stream" });

   /* Downloading file locally 

      //local path of the directory where we want to download the file
      const dirName = "./public/temp";
      // the above path is not a valid path it should use "\" instead of "/"
      // to do so we use path.join()
      const localPath = path.join(dirName, "Downloaded File.jpg");
      response.data.pipe(fs.createWriteStream(localPath));

   */
   res.set({
      "content-type": response.headers.getContentType(),
      "content-disposition": `attachment; filename="Fetched from DB.png"`,
   });

   // response.data is a readable stream
   // pipe method allows to connect readable stream to a writable stream
   // res is a writable stream (we can write data to it)
   response.data.pipe(res);
   res.status(200);
});

export {
   registerUser,
   loginUser,
   logoutUser,
   refreshAccessToken,
   changeCurrentPassword,
   getCurrentUser,
   updateAccountDetails,
   updateUserAvatar,
   updateUserCoverImage,
   getUserChannelProfile,
   getWatchHistory,
   downloadAvatar,
   downloadCoverImage,
};
